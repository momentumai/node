var config = require('@config'),
    path = require('path'),
    gcloud = require('gcloud'),
    Promise = require('bluebird'),
    uuid = require('uuid'),
    ds = {};

function getDataStore (namespace) {
    var cfg = {
        'projectId': config.google.projectId,
        'credentials': config.google.credentials
    };

    if (namespace) {
        cfg.namespace = String(namespace);
    }

    return gcloud.datastore(cfg);
}

ds.init = function (namespace) {
    return Promise.resolve().then(function () {
        return getDataStore(namespace);
    }).catch(function () {
        return ds.init(namespace);
    });
};

ds.toKey = function (kind, key, namespace, datastore) {
    datastore = datastore || getDataStore(namespace);
    return datastore.key([String(kind), String(key)]);
};

ds.jsonToKey = function (json, datastore) {
    return ds.toKey(
        json.kind,
        json.name,
        json.namespace,
        datastore
    );
};

function getElement (model, key, item) {
    var resp = {};

    resp.name = key;
    resp.value = item.data[key];
    resp.excludeFromIndexes = model.excludeIndexes.indexOf(key) !== -1;

    return resp;
}

function get (kind, keys, namespace, datastore) {
    datastore = datastore || getDataStore(namespace);
    return (new Promise(function (resolve, reject) {
        datastore.get(keys.reduce(function (prev, act) {
            prev.push(ds.toKey(kind, act, null, datastore));
            return prev;
        }, []), function (err, resp) {
            if (err) {
                return reject(err);
            }
            return resolve(resp || []);
        });
    })).catch(function (err) {
        if (err.code === 503) {
            return get(kind, keys, namespace, datastore);
        }

        throw err;
    });
}

function set (kind, data, namespace, datastore) {
    var model = require(path.join('@lib', 'model', 'datastore', kind));

    datastore = datastore || getDataStore(namespace);
    return (new Promise(function (resolve, reject) {
        var dsData = data.reduce(function (prev, act) {
            prev.push({
                'key': ds.toKey(kind, act.key || uuid.v4(), null, datastore),
                'data': Object.keys(act.data).reduce(function (prev, key) {
                    prev.push(getElement(model, key, act));
                    return prev;
                }, [])
            });
            return prev;
        }, []);

        datastore.upsert(dsData, function (err) {
            if (err) {
                return reject(err);
            }
            return resolve(dsData.map(function (item) {
                return {
                    'key': item.key,
                    'data': item.data.reduce(function (prev, act) {
                        prev[act.name] = act.value;
                        return prev;
                    }, {})
                };
            }));
        });
    })).catch(function (err) {
        if (err.code === 503) {
            return set(kind, data, namespace, datastore);
        }

        throw err;
    });
}

function batch (func, kind, items, namespace, datastore) {
    var single = false,
        promises = [],
        part;

    if (items && !Array.isArray(items)) {
        items = [items];
        single = true;
    }

    if (!items || !items.length) {
        return Promise.resolve([]);
    }
    part = items.splice(0, 250);
    while (part.length) {
        promises.push(func(kind, part.slice(), namespace, datastore));
        part = items.splice(0, 250);
    }

    return Promise.all(promises).then(function (resp) {
        var data = [].concat.apply([], resp);

        if (single) {
            return data && data[0] || null;
        }
        return data;
    });
}

function del (kind, keys, namespace, datastore) {
    datastore = datastore || getDataStore(namespace);
    return (new Promise(function (resolve, reject) {
        datastore.delete(keys.map(function (key) {
            return ds.toKey(kind, key, null, datastore);
        }), function (err) {
            if (err) {
                return reject(err);
            }
            return resolve();
        });
    })).catch(function (err) {
        if (err.code === 503) {
            return ds.delete(kind, keys, namespace);
        }

        throw err;
    });
}

/**
 * get items
 *
 * Provides the ability to get items
 *
 * @param {string} kind
 *   Name of the Kind
 * @param {array} keys
 *   array of string. can be only one string, don't have to be array
 * @param {string} namespace
 *   optional namespace
 * @param {Datastore} datastore
 *   optional datastore instance
 */
ds.get = function (kind, keys, namespace, datastore) {
    return batch(get, kind, keys, namespace, datastore);
};

/**
 * update or insert items
 *
 * Provides the ability to upsert(update or insert) items
 *
 * @param {string} kind
 *   Name of the Kind
 * @param {array} data
 *   array of object. can be only one Object, don't have to be array
 *   the items of the array or the object has to be the following format:
 *     {
 *        'key': 'KeyOfTheItem',
 *        'data': {
 *            'update-param-1': 'new-value-1',
 *            'update-param-2': 'new-value-2',
 *        }
 *    }
 * @param {string} namespace
 *   optional namespace
 * @param {Datastore} datastore
 *   optional datastore instance
 */
ds.set = function (kind, data, namespace, datastore) {
    return batch(set, kind, data, namespace, datastore);
};

/**
 * Delete items
 *
 * Provides the ability to delete items
 *
 * @param {string} kind
 *   Name of the Kind
 * @param {array} keys
 *   array with the keys. can be only one String, don't have to be array
 * @param {string} namespace
 *   optional namespace
 * @param {Datastore} datastore
 *   optional datastore instance
 */
ds.delete = function (kind, keys, namespace, datastore) {
    return batch(del, kind, keys, namespace, datastore);
};

/**
 * Runs a query
 *
 * Provides the ability to run a query
 * It will run through the queryFunction.
 *
 * @param {string} kind
 *   Name of the Kind
 * @param {function} queryFunction
 *   params for the function:
 *                {Query} query the query
 *                {Datastore} datastore the datastore instance
 * @param {string} namespace
 *   optional namespace
 * @param {Datastore} datastore
 *   optional datastore instance
 */
ds.query = function (kind, queryFunction, namespace, datastore) {
    datastore = datastore || getDataStore(namespace);

    return (new Promise(function (resolve, reject) {
        var query = queryFunction(datastore.createQuery(kind), datastore);

        datastore.runQuery(
            query,
            function (err, resp, nextQuery) {
                if (err) {
                    return reject(err);
                }
                if (query.limitVal >= 0) {
                    return resolve({
                        'data': resp || null,
                        'nextQuery': nextQuery
                    });
                }
                return resolve(resp || null);
            }
        );
    })).catch(function (err) {
        if (err.code === 503) {
            return ds.runQuery(kind, queryFunction, namespace);
        }

        throw err;
    });
};
/**
 * Updates an item transactionally
 *
 * Provides the ability to extend an item.
 * It will run through the updateFunction.
 *
 * @param {string} kind
 *   Name of the Kind
 * @param {string} key
 *   Key of the array
 * @param {function} updateFunction
 *   params for the function:
 *                {object} data data of the item,
 *                {Key} key key of the item,
 * @param {string} namespace
 *   optional namespace
 * @param {Datastore} datastore
 *   optional datastore instance
 */
ds.extend = function (kind, key, updateFunction, namespace, datastore) {
    var transaction,
        model = require(path.join('@lib', 'model', 'datastore', kind));

    datastore = datastore || getDataStore(namespace);
    transaction = datastore.transaction();

    if (!key) {
        return Promise.resolve([]);
    }
    return new Promise(function (resolve, reject) {
        transaction.run(function (err) {
            if (err) {
                return reject(err);
            }
            transaction.get([
                ds.toKey(kind, key || uuid.v4(), null, datastore)
            ], function (err, resp) {
                var item;

                if (err) {
                    return transaction.rollback(function (getError) {
                        return reject(getError || err);
                    });
                }

                item = resp && resp[0];
                if (item && item.key) {
                    item.data = updateFunction(item.data || {}, item.key);
                    item.data = Object.keys(item.data)
                        .reduce(function (prev, act) {
                            prev.push(getElement(model, act, item));
                            return prev;
                        }, []);
                }

                transaction.save(item);
                transaction.commit(function (err) {
                    if (err) {
                        return reject(err);
                    }
                    return resolve(item.data);
                });
            });
        });
    });
};

module.exports = ds;
