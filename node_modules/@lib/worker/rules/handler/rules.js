var RuleEngine = require('node-rules'),
    Promise = require('bluebird');

function makeRuleFromJSON (json) {
    return [{
        'condition': function (R) {
            var OR = [];

            function getOpStr (operator, metric, value) {
                if (Number.isNaN(Number(value))) {
                    throw new Error('Value is NaN: ' + value);
                }

                if (operator === 'GT') {
                    return [
                        metric,
                        '>',
                        value
                    ].join(' ');
                }
                if (operator === 'LT') {
                    return [
                        metric,
                        '<',
                        value
                    ].join(' ');
                }
                if (operator === 'EQ') {
                    return [
                        metric,
                        '===',
                        value
                    ].join(' ');
                }
                throw new Error('Unknown operator: ' + operator);
            }

            function transform (def) {
                var ops = [];

                Object.keys(def).forEach(function (metric) {
                    var operator;

                    operator = Object.keys(def[metric])[0];

                    ops.push(
                        '(' +
                        getOpStr(operator, metric, def[metric][operator]) +
                        ')'
                    );
                });

                return '(' + ops.join(' && ') + ')';
            }

            json.OR.forEach(function (def) {
                OR.push(transform(def));
            });

            // eslint-disable-next-line
            with (this) {
                R.when(eval(OR.join(' || ')));
            }
        },
        'consequence': function (R) {
            this.result = json.action;
            R.stop();
        }
    }];
}

function getRules (ruleData) {
    var ret = {};

    ruleData.forEach(function (ruleDatum) {
        var ruleDef = JSON.parse(ruleDatum.definition),
            engine = new RuleEngine(makeRuleFromJSON(ruleDef));

        engine.id = ruleDatum.id;
        engine.parent = ruleDatum.parent;

        ret[ruleDatum.id] = engine;
    });

    return ret;
}

module.exports.getResult = function (facts, ruleData) {
    var rules = getRules(ruleData),
        promises = {};

    Object.keys(facts).forEach(function (ruleId) {
        var rulePromises = [],
            ret = [];

        facts[ruleId].forEach(function (fact) {
            rulePromises.push(new Promise(function (resolve) {
                rules[ruleId].execute(fact, function (processed) {
                    if (typeof processed.result === 'object') {
                        processed.rule_id = ruleId;
                        processed.parent = rules[ruleId].parent;
                        ret.push(processed);
                    }
                    resolve();
                });
            }));
        });

        promises[ruleId] = Promise.all(rulePromises).then(function () {
            return ret;
        });
    });

    return Promise.props(promises).then(function (res) {
        return Object.keys(res).reduce(function (prev, act) {
            prev = prev.concat(res[act]);
            return prev;
        }, []);
    });
};
