var path = require('path'),
    db = require('@lib/resources/db'),
    sqlUtils = require('@lib/utils/sql'),
    q = sqlUtils.getQueries(path.join(__dirname, 'sql')),
    config = require('@config'),
    Promise = require('bluebird'),
    uuid = require('@lib/utils/uuid'),
    rule = {};

rule.setDefault = function (teamId, cats, pool) {
    return Promise.all(
        config.rules.reduce(function (prev, act) {
            prev.push(
                db.q(q['insert_default'], {
                    'team_id': teamId,
                    'cat1': cats[0],
                    'cat2': cats[1],
                    'cat3': cats[2],
                    'name': act.name,
                    'module': act.module,
                    'definition': JSON.stringify(
                        act.definition,
                        null,
                        4
                    )
                }, pool)
            );
            return prev;
        }, [])
    );
};

rule.list = function (userId, teamId, pool) {
    return db.q(q['rule_list'], {
        'user_id': userId,
        'team_id': teamId
    }, pool);
};

rule.save = function (userId, teamId, isAdmin, data, pool) {
    var promises = {};

    function handleAdd (items) {
        return Promise.all(
            items.reduce(function (prev, act) {
                var promise = db.q(q['insert'], {
                    'team_id': teamId,
                    'cat1': act.cat1,
                    'cat2': act.cat2,
                    'cat3': act.cat3,
                    'definition': act.definition,
                    'module': act.module,
                    'name': uuid.next()
                }, pool);

                if (act.options) {
                    promise = promise.then(function (res) {
                        return db.q(q['insert_options'], {
                            'team_id': teamId,
                            'user_id': userId,
                            'key': 'rule_' + res.insertId,
                            'value': act.options
                        }, pool);
                    });
                }

                prev.push(promise);

                return prev;
            }, [])
        );
    }

    function handleDelete (items) {
        return Promise.all(
            items.reduce(function (prev, act) {
                prev.push(
                    db.q(q['delete'], {
                        'team_id': teamId,
                        'rule_id': act.id
                    }, pool)
                );
                return prev;
            }, [])
        );
    }

    function handleUpdate (items) {
        return Promise.all(
            items.reduce(function (prev, act) {
                var promise = Promise.resolve();

                if (act.options && act.my) {
                    promise = db.q(q['delete_options'], {
                        'team_id': teamId,
                        'key': 'rule_' + act.id
                    }, pool).then(function () {
                        return db.q(q['insert_options'], {
                            'team_id': teamId,
                            'user_id': userId,
                            'key': 'rule_' + act.id,
                            'value': act.options
                        }, pool);
                    });
                }

                promise = promise.then(function () {
                    return db.q(q['update'], {
                        'rule_id': act.id,
                        'team_id': teamId,
                        'definition': act.definition,
                        'module': act.module
                    }, pool);
                });

                prev.push(promise);

                return prev;
            }, [])
        );
    }

    if (!isAdmin) {
        throw 'model/rule:403:Unauthorized access';
    }

    if (data && data.add && data.add.length) {
        promises['add'] = handleAdd(data.add);
    }

    if (data && data.delete && data.delete.length) {
        promises['delete'] = handleDelete(data.delete);
    }

    if (data && data.update && data.update.length) {
        promises['update'] = handleUpdate(data.update);
    }

    return Promise.props(promises).then(function () {
        return {};
    });
};

module.exports = rule;
