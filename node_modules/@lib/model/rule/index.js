var path = require('path'),
    db = require('@lib/resources/db'),
    sqlUtils = require('@lib/utils/sql'),
    q = sqlUtils.getQueries(path.join(__dirname, 'sql')),
    config = require('@config'),
    Promise = require('bluebird'),
    uuid = require('@lib/utils/uuid'),
    rule = {};

rule.setDefault = function (teamId, cats, pool) {
    return Promise.all(
        config.rules.reduce(function (prev, act) {
            prev.push(
                db.q(q['insert_default'], {
                    'team_id': teamId,
                    'cat1': cats[0],
                    'cat2': cats[1],
                    'cat3': cats[2],
                    'name': act.name,
                    'module': act.module,
                    'definition': JSON.stringify(
                        act.definition,
                        null,
                        4
                    )
                }, pool)
            );
            return prev;
        }, [])
    );
};

rule.list = function (userId, teamId, pool) {
    return db.q(q['rule_list'], {
        'user_id': userId,
        'team_id': teamId
    }, pool);
};

rule.save = function (userId, teamId, isAdmin, data, pool) {
    var promises = {},
        connections = {};

    function handleAdd (items) {
        return Promise.props(
            items.reduce(function (prev, act) {
                var insertId,
                    promise = db.q(q['insert'], {
                        'team_id': teamId,
                        'cat1': act.cat1,
                        'cat2': act.cat2,
                        'cat3': act.cat3,
                        'definition': act.definition,
                        'module': act.module,
                        'name': uuid.next(),
                        'parent': act.parent || 'NULL'
                    }, pool);

                if (act.options) {
                    promise = promise.then(function (res) {
                        insertId = res.insertId;
                        return db.q(q['insert_options'], {
                            'team_id': teamId,
                            'user_id': userId,
                            'key': 'rule_' + res.insertId,
                            'value': act.options
                        }, pool);
                    });
                }

                promise = promise.then(function (res) {
                    if (!insertId) {
                        insertId = res.insertId;
                    }
                    return insertId;
                });

                prev[act.id] = promise;

                return prev;
            }, {})
        );
    }

    function handleDelete (items) {
        return Promise.all(
            items.reduce(function (prev, act) {
                prev.push(
                    db.q(q['delete'], {
                        'team_id': teamId,
                        'rule_id': act.id
                    }, pool)
                );
                return prev;
            }, [])
        );
    }

    function handleUpdate (items) {
        return Promise.all(
            items.reduce(function (prev, act) {
                var promise = Promise.resolve();

                if (act.options && act.my) {
                    promise = db.q(q['delete_options'], {
                        'team_id': teamId,
                        'key': 'rule_' + act.id
                    }, pool).then(function () {
                        return db.q(q['insert_options'], {
                            'team_id': teamId,
                            'user_id': userId,
                            'key': 'rule_' + act.id,
                            'value': act.options
                        }, pool);
                    });
                }

                promise = promise.then(function () {
                    return db.q(q['update'], {
                        'rule_id': act.id,
                        'team_id': teamId,
                        'definition': act.definition,
                        'module': act.module,
                        'parent': act.parent || 'NULL'
                    }, pool);
                });

                prev.push(promise);

                return prev;
            }, [])
        );
    }

    function handleConnections (connections, idMap) {
        return Promise.all(
            Object.keys(connections).reduce(function (prev, act) {
                var id,
                    parent;

                if (!act.indexOf('new_')) {
                    id = idMap[act];
                } else {
                    id = act;
                }

                parent = idMap[connections[act]];

                prev.push(db.q(q['update_parent'], {
                    'id': id,
                    'parent': parent
                }, pool));

                return prev;
            }, [])
        );
    }

    if (!isAdmin) {
        throw 'model/rule:403:Unauthorized access';
    }

    data.add.concat(data.update).forEach(function (req) {
        if (!String(req.parent).indexOf('new_')) {
            connections[req.id] = req.parent;
            req.parent = null;
        }
    });

    if (data && data.add && data.add.length) {
        promises['add'] = handleAdd(data.add);
    }

    if (data && data.delete && data.delete.length) {
        promises['delete'] = handleDelete(data.delete);
    }

    if (data && data.update && data.update.length) {
        promises['update'] = handleUpdate(data.update);
    }

    return Promise.props(promises).then(function (res) {
        return handleConnections(connections, res.add);
    });
};

module.exports = rule;
