var time = require('@lib/utils/time'),
    ds = require('@lib/resources/datastore'),
    publicInfo = require('@lib/model/content/public-info'),
    compress = require('@lib/utils/compress'),
    dUtils = require('@lib/utils/dashboard'),
    urlUtils = require('@lib/utils/url'),
    _ = require('lodash'),
    Promise = require('bluebird'),
    toplist = {};

function transform (teamId, cats, to, from) {
    function graphData (res, data, byTime) {
        var interval,
            metrics = ['share', 'view', 'user'];

        res.chart = {
            'data': {},
            'from': from
        };

        res.stats = {
            'share': {
                'sum': Number(data.share),
                'values': {}
            },
            'view': {
                'sum': Number(data.view),
                'values': {}
            },
            'user': {
                'sum': Number(data.user),
                'values': {}
            }
        };

        byTime = _.groupBy(
            byTime,
            function (act) {
                return act[0];
            }
        );

        byTime = Object.keys(byTime).reduce(function (prev, timestamp) {
            prev[timestamp] = {
                'share': Number(byTime[timestamp][0][1]),
                'view': Number(byTime[timestamp][0][2]),
                'user': Number(byTime[timestamp][0][3])
            };
            return prev;
        }, {});

        for (interval = to; interval > from; interval -= 300) {
            res.chart.data[interval] = 0;

            metrics.forEach(function (metric) {
                res.stats[metric].values[interval] = 0;
            });

            if (byTime[interval] && byTime[interval].share) {
                res.chart.data[interval] = byTime[interval].share;
            }

            metrics.forEach(function (metric) {
                if (byTime[interval] && byTime[interval][metric]) {
                    res.stats[
                        metric
                    ].values[interval] = byTime[interval][metric];
                }
            });
        }

        res.chart.data = compress.sumByCount(
            res.chart.data,
            96
        );

        metrics.forEach(function (metric) {
            res.stats[metric].values = compress.sumByCount(
                res.stats[metric].values,
                48
            );
        });
    }

    return function (data) {
        var res = {},
            otp = {
                '1': 'organic',
                '2': 'team',
                '3': 'paid'
            },
            byTime;

        if (!data || !data.value) {
            return Promise.resolve(null);
        }

        data = JSON.parse(data.value);

        res.source = dUtils.stringToMatrix(data['source'], '||||');

        byTime = dUtils.stringToMatrix(data['by_time'], '||');

        graphData(res, data, byTime);

        res.source = res.source.reduce(function (prev, act) {
            prev[otp[act[0][0]]] = act[1].reduce(function (prev, act) {
                var elem = {};

                elem[act[0]] = Number(act[1]);

                prev.push(elem);
                return prev;
            }, []);
            return prev;
        }, {});

        res.organic = Number(data.organic);
        res.team = Number(data.team);
        res.paid = Number(data.paid);

        res.contentId = data['content_id'];

        res.share = Number(data.share);
        res.view = Number(data.view);
        res.user = Number(data.user);

        return res;
    };
}

function getURL (teamId) {
    return function (data) {
        if (!data) {
            return Promise.resolve(null);
        }

        return ds.init(teamId).then(function (datastore) {
            var query = datastore.createQuery('Content');

            query.filter('content_id', data.contentId);

            return ds.runQuery(query, datastore).then(function (queryResult) {
                if (!queryResult && !queryResult.length) {
                    return Promise.resolve(null);
                }

                data.url = queryResult[0].key.name;
                data.blacklist = queryResult[0].data.is_blacklisted;
                data.shareLink = urlUtils.addShareParams(data.url);

                return data;
            });
        });
    };
}

function getPublicInfo (teamId) {
    return function (data) {
        if (!data) {
            return Promise.resolve(null);
        }

        return publicInfo.get(teamId, data.url).then(function (res) {
            data.ogdata = res;
            return data;
        });
    };
}

toplist.get = function (teamId, cats, now) {
    var to = time.toMinutes(5, 10, now),
        from = time.subtractOneDay(to),
        key_min = [teamId, 'NONE', 'NONE', 'NONE', '1'].join('||'),
        key_max = [teamId, 'NONE', 'NONE', 'NONE', '9'].join('||');

    return ds.init().then(function (datastore) {
        var q = datastore.createQuery('RealtimeContentModel');

        q = q.filter('__key__', '>', datastore.key(
            ['RealtimeContentModel', key_min]
        ));
        q = q.filter('__key__', '<', datastore.key(
            ['RealtimeContentModel', key_max]
        ));
        q = q.order('__key__', {'descending': true});
        q = q.limit(50);

        return ds.runQuery(q, datastore);
    }).then(function (rows) {
        return rows;
    });
};

toplist.get_old = function (teamId, cats, now) {
    var i = 1,
        promises = {},
        to = time.toMinutes(5, 10, now),
        from = time.subtractOneDay(to);

    for (; i < 11; i += 1) {
        promises[i] = ds.get(
            null,
            'RealtimeContentModel',
            [
                teamId,
                ['NONE', 'NONE', 'NONE'].join('||'),
                to,
                i
            ].join('||')
        ).then(
            transform(teamId, cats, to, from)
        ).then(
            getURL(teamId)
        ).then(
            getPublicInfo(teamId)
        );
    }

    return Promise.props(promises).then(function (res) {
        var sum,
            data = Object.keys(res).sort().filter(function (rank) {
                return res[rank];
            }).map(function (rank) {
                return res[rank];
            });

        sum = data.reduce(function (prev, act) {
            prev += act.share;
            return prev;
        }, 0);

        data.forEach(function (act) {
            act.momentum = act.share / sum;
        });

        return data;
    });
};

module.exports = toplist;
