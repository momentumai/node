var time = require('@lib/utils/time'),
    ds = require('@lib/resources/datastore'),
    publicInfo = require('@lib/model/content/public-info'),
    compress = require('@lib/utils/compress'),
    dUtils = require('@lib/utils/dashboard'),
    urlUtils = require('@lib/utils/url'),
    _ = require('lodash'),
    Promise = require('bluebird'),
    toplist = {};

function transform (teamId, to, from, data) {
    var res = {},
        otp = {
            '1': 'organic',
            '2': 'team',
            '3': 'paid'
        },
        byTime;

    function graphData (res, data, byTime) {
        var interval,
            metrics = ['share', 'view', 'user'];

        res.chart = {
            'data': {},
            'from': from
        };

        res.stats = {
            'share': {
                'sum': Number(data.share),
                'values': {}
            },
            'view': {
                'sum': Number(data.view),
                'values': {}
            },
            'user': {
                'sum': Number(data.user),
                'values': {}
            }
        };

        byTime = _.groupBy(
            byTime,
            function (act) {
                return act[0];
            }
        );

        byTime = Object.keys(byTime).reduce(function (prev, timestamp) {
            prev[timestamp] = {
                'share': Number(byTime[timestamp][0][1]),
                'view': Number(byTime[timestamp][0][2]),
                'user': Number(byTime[timestamp][0][3])
            };
            return prev;
        }, {});

        for (interval = to; interval > from; interval -= 300) {
            res.chart.data[interval] = 0;

            metrics.forEach(function (metric) {
                res.stats[metric].values[interval] = 0;
            });

            if (byTime[interval] && byTime[interval].share) {
                res.chart.data[interval] = byTime[interval].share;
            }

            metrics.forEach(function (metric) {
                if (byTime[interval] && byTime[interval][metric]) {
                    res.stats[
                        metric
                    ].values[interval] = byTime[interval][metric];
                }
            });
        }

        res.chart.data = compress.sumByCount(
            res.chart.data,
            96
        );

        metrics.forEach(function (metric) {
            res.stats[metric].values = compress.sumByCount(
                res.stats[metric].values,
                48
            );
        });
    }

    res.source = dUtils.stringToMatrix(data['source'], '||||') || [];

    byTime = dUtils.stringToMatrix(data['by_time'], '||') || [];

    graphData(res, data, byTime);

    res.source = res.source.reduce(function (prev, act) {
        prev[otp[act[0][0]]] = act[1].reduce(function (prev, act) {
            var elem = {};

            elem[act[0]] = Number(act[1]);

            prev.push(elem);
            return prev;
        }, []);
        return prev;
    }, {});

    res.organic = Number(data.organic);
    res.team = Number(data.team);
    res.paid = Number(data.paid);

    res.contentId = data['content_id'];

    res.share = Number(data.share);
    res.view = Number(data.view);
    res.user = Number(data.user);

    return Promise.resolve(res);
}

function getURL (teamId) {
    return function (data) {
        return ds.init(teamId).then(function (datastore) {
            var query = datastore.createQuery('Content');

            query.filter('content_id', data.contentId);

            return ds.runQuery(query, datastore).then(function (queryResult) {
                if (!queryResult || !queryResult.length) {
                    console.error(data);
                    return Promise.resolve({});
                }

                data.url = queryResult[0].key.name;
                data.blacklist = queryResult[0].data.is_blacklisted;
                data.shareLink = urlUtils.addShareParams(data.url);

                return data;
            });
        });
    };
}

function getPublicInfo (teamId) {
    return function (data) {
        return publicInfo.get(teamId, data.url).then(function (res) {
            data.ogdata = res;
            return data;
        });
    };
}

toplist.get = function (teamId, cats, now) {
    var to = now,
        from = time.subtractOneDay(to),
        keyMin = [
            teamId,
            cats.join('||'),
            '1'
        ].join('||'),
        keyMax = [
            teamId,
            cats.join('||'),
            to + 1
        ].join('||');

    return ds.init().then(function (datastore) {
        var q = datastore.createQuery('RealtimeContentModel');

        q = q.filter('__key__', '>', datastore.key(
            ['RealtimeContentModel', keyMin]
        ));

        q = q.filter('__key__', '<', datastore.key(
            ['RealtimeContentModel', keyMax]
        ));
        q = q.order('__key__', {'descending': true});
        q = q.limit(30);

        return ds.runQuery(q, datastore);
    }).then(function (rows) {
        var res = [],
            first;

        rows.forEach(function (row) {
            var act,
                timestamp;

            if (row && row.data && row.data.value) {
                timestamp = Number(row.key.name.split('||')[4]);
                if (!first) {
                    first = timestamp;
                }

                if (first === timestamp) {
                    act = JSON.parse(row.data.value);
                    res.push(act);
                }
            }
        });

        return res;
    }).then(function (rows) {
        var promises = {};

        rows.forEach(function (row) {
            promises[row.rank] = transform(
                teamId,
                to,
                from,
                row
            ).then(
                getURL(teamId)
            ).then(
                getPublicInfo(teamId)
            );
        });

        return Promise.props(promises).then(function (res) {
            var sum,
                multi = [0.7, 0.5, 0.4, 0.3, 0.1, 0.1],
                data = Object.keys(res).sort(function (a, b) {
                    return Number(a) - Number(b);
                }).filter(function (rank) {
                    return res[rank];
                }).map(function (rank) {
                    return res[rank];
                });

            sum = data.reduce(function (prev, act, index) {
                prev += act.share * (multi[index] || 0);
                return prev;
            }, 0);

            sum = Math.max(
                Number(data[0] && data[0].share || 0) + 1,
                sum
            );

            data.forEach(function (act) {
                act.momentum = act.share / sum;
            });

            data = _.uniqBy(data, function (e) {
                return e.contentId;
            });

            data.sort(function (a, b) {
                return a.momentum > b.momentum ? -1 : 1;
            });

            return data;
        });
    });
};

module.exports = toplist;
