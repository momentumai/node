var time = require('@lib/utils/time'),
    ds = require('@lib/resources/datastore'),
    compress = require('@lib/utils/compress'),
    dUtils = require('@lib/utils/dashboard'),
    _ = require('lodash'),
    stats = {};

stats.get = function (teamId, cats, now) {
    var to = time.toMinutes(5, 10, now),
        from = time.subtractOneDay(to),
        interval;

    return ds.get(null, 'RealtimeDashboardModel', [
        teamId,
        cats.join('||'),
        to
    ].join('||')).then(function (data) {
        var value = {
            'by_time': '',
            'share': 0,
            'view': 0,
            'user': 0
        };

        try {
            value = JSON.parse(data.value);
        } catch (ignore) {
            //ignore
        }

        return value;
    }).then(function (data) {
        var res = dUtils.stringToMatrix(data.by_time, '||') || [],
            metrics = ['share', 'view', 'user'],
            ret = {
                'chart': {
                    'data': {},
                    'from': from
                },
                'stats': {
                    'share': {
                        'sum': Number(data.share),
                        'values': {}
                    },
                    'view': {
                        'sum': Number(data.view),
                        'values': {}
                    },
                    'user': {
                        'sum': Number(data.user),
                        'values': {}
                    }
                }
            };

        res = _.groupBy(res, function (act) {
            return act[0];
        });

        res = Object.keys(res).reduce(function (prev, timestamp) {
            prev[timestamp] = {
                'share': Number(res[timestamp][0][1]),
                'view': Number(res[timestamp][0][2]),
                'user': Number(res[timestamp][0][3])
            };
            return prev;
        }, {});

        for (interval = to; interval > from; interval -= 300) {
            /* reset data */
            ret.chart.data[interval] = 0;

            metrics.forEach(function (metric) {
                ret.stats[metric].values[interval] = 0;
            });

            /* override */
            if (res[interval] && res[interval].share) {
                ret.chart.data[interval] = res[interval].share;
            }

            metrics.forEach(function (metric) {
                if (res[interval] && res[interval][metric]) {
                    ret.stats[metric].values[interval] = res[interval][metric];
                }
            });
        }

        ret.chart.data = compress.sumByCount(
            ret.chart.data,
            96
        );

        metrics.forEach(function (metric) {
            ret.stats[metric].values = compress.sumByCount(
                ret.stats[metric].values,
                48
            );
        });

        return ret;
    });
};

module.exports = stats;
