var path = require('path'),
    config = require('@config'),
    bcrypt = require('bcrypt'),
    crypto = require('crypto'),
    Promise = require('bluebird'),
    db = require('@lib/resources/db'),
    ds  = require('@lib/resources/datastore'),
    sqlUtils = require('@lib/utils/sql'),
    ses = require('@lib/resources/ses'),
    hubspot = require('@lib/utils/hubspot'),
    cryptoUtils = require('@lib/utils/crypto'),
    dynamo = require('@lib/resources/dynamodb'),
    logger = require('@lib/logger')('model/auth'),
    rule = require('@lib/model/rule'),
    q = sqlUtils.getQueries(path.join(__dirname, 'sql')),
    INVITE_TOKEN_TIMEOUT = 1000 * 3600 * 24 * 7,
    REMINDER_TOKEN_TIMEOUT = 3600 * 24,
    auth = {};

auth.getUser = function (userId, teamId, pool) {
    function hasData (teamId) {
        return ds.init(teamId).then(function (datastore) {
            var query = datastore.createQuery('Content');

            query.limit(1);
            return ds.runQuery(query, datastore);
        }).then(function (data) {
            return Boolean(data && data.length);
        });
    }

    return Promise.all([
        hasData(teamId),
        db.q(q['properties'], {
            'team_id': teamId,
            'user_id': userId
        }, pool).then(function (rows) {
            var guide = JSON.parse(rows[0].guide);

            return {
                'email': rows[0].email,
                'payment_amount': rows[0].payment_amount,
                'is_super': rows[0].is_super,
                'is_admin': rows[0].is_admin,
                'team_id': cryptoUtils.encryptId(String(teamId)),
                'real_team_id': teamId,
                'guide': guide
            };
        })
    ]).then(function (res) {
        if (res[0]) {
            res[1].guide['tracking_code'] = 'live';
        }

        return res[1];
    });
};

auth.removeUser = function (userId, teamId, removeId, isAdmin, pool) {
    if (userId === removeId) {
        return auth.getUsers(userId, teamId, pool);
    }

    if (!isAdmin) {
        throw 'model/auth:403:Unauthorized access';
    }

    return db.q(q['remove_user'], {
        'remove_id': removeId,
        'team_id': teamId
    }, pool).then(function () {
        return db.q(q['remove_user_session'], {
            'remove_id': removeId,
            'team_id': teamId
        }, pool);
    }).then(function () {
        return auth.getUsers(userId, teamId, pool);
    });
};

auth.getUsers = function (userId, teamId, pool) {
    return db.q(q['get_users'], {
        'user_id': userId,
        'team_id': teamId
    }, pool);
};

auth.logout = function (sessionId, now, pool) {
    return db.q(q['delete_session'], {
        'session_id': sessionId
    }, pool);
};

auth.login = function (email, password, now, pool) {
    var res = {};

    email = db.escape(email);
    password = db.escape(password);

    return db.q(q['user'], {
        'email': email
    }, pool).then(function (rows) {
        var lastTeam = rows[0];

        if (!rows.length ||
            !bcrypt.compareSync(password, rows[0].password_hash)) {
            throw 'auth/login:400:Wrong email or password';
        }
        rows.forEach(function (team) {
            if (Number(team.last)) {
                lastTeam = team;
            }
        });
        res.team_id = lastTeam.team_id;
        res.email = email;
        res.user_id = lastTeam.id;
    }).then(function () {
        var params = {
            'timeout': now + config.sessionTimeout,
            'user_id': res.user_id,
            'team_id': res.team_id
        };

        return db.q(q['session'], params, pool);
    }).then(function (result) {
        res.session_id = cryptoUtils.encryptId(String(result.insertId));
        return res;
    });
};

function addToPartner (context, pool) {
    var promises = [];

    promises.push(db.q(q['add_fb_asset'], {
        'team_id': context.teamId,
        'user_id': 153,
        'type': 1,
        'value': config.facebook.page,
        'display': 'Momentum Partner',
        'is_default': 0
    }, pool));

    promises.push(db.q(q['add_fb_asset'], {
        'team_id': context.teamId,
        'user_id': 147,
        'type': 1,
        'value': config.facebook.page,
        'display': 'Momentum Partner',
        'is_default': 0
    }, pool));

    promises.push(db.q(q['add_fb_asset'], {
        'team_id': context.teamId,
        'user_id': 153,
        'type': 2,
        'value': config.facebook.adAccount,
        'display': 'Momentum Partner',
        'is_default': 0
    }, pool));

    promises.push(db.q(q['add_fb_asset'], {
        'team_id': context.teamId,
        'user_id': 147,
        'type': 2,
        'value': config.facebook.adAccount,
        'display': 'Momentum Partner',
        'is_default': 0
    }, pool));

    return Promise.all(promises);
}

auth.getCode = function (id) {
    return config.trackingCode.replace(
        '{{team_id}}',
        cryptoUtils.encryptId(String(id))
    );
};

auth.register = function (email, teamName, code, partner, payment, now, pool) {
    var local = {};

    if (!teamName) {
        throw 'auth/login:400:Team name is missing';
    }
    if (!email) {
        throw 'auth/login:400:Email address is missing';
    }
    email = db.escape(email);
    teamName = db.escape(teamName);

    return db.q(q['get_user'], {
        'email': email
    }, pool).then(function (rows) {
        if (!rows.length) {
            local.userIsNew = 1;
            return db.q(q['insert_user'], {
                'email': email,
                'password_hash': ''
            }, pool).then(function (result) {
                return result.insertId;
            });
        }

        return rows[0].id;
    }).then(function (result) {
        payment = Number(payment);
        local.userId = result;

        return db.q(q['insert_team'], {
            'timestamp': now,
            'team_name': teamName,
            'payment_amount': payment
        }, pool);
    }).then(function (result) {
        local.teamId = result.insertId;
        return rule.setDefault(
            local.teamId,
            [0, 0, 0],
            pool
        ).then(function () {
            return dynamo.init();
        });
    }).then(function (dynamodb) {
        var item = {};

        item.id = String(local.teamId);
        item.range = '1';
        item.tracking = 1;

        return dynamo.putItem('team', item, dynamodb);
    }).then(function () {
        return db.q(q['insert_team_user'], {
            'team_id': local.teamId,
            'user_id': local.userId
        }, pool);
    }).then(function () {
        if (Number(partner)) {
            return addToPartner(local, pool);
        }
    }).then(function () {
        if (local.userIsNew) {
            return hubspot.insertToList(email, 849);
        }
    }).then(function () {
        if (local.userIsNew) {
            return auth.forgotPassword(email, pool);
        }
    }).then(function () {
        if (code) {
            return auth.sendCode(local.teamId, email);
        }
    }).then(function () {
        return auth.getCode(local.teamId);
    });
};

function getCodeText (id) {
    var subject,
        message = '';

    subject = 'Insert code for Momentum';

    message += 'Hi there,\n\n';

    message += 'Insert this code between the <head> and </head> ';
    message += 'tags of your website\n\n';

    message += auth.getCode(id);

    message += '\n\n';
    message += 'If you have any questions or feel lost, ';
    message += 'drop us a mail at support@momentum.ai\n\n';
    message += 'Best,\n';
    message += 'Zoltan';

    return {
        'subject': subject,
        'message': message
    };
}

auth.sendCode = function (teamId, email) {
    var emailData;

    emailData = getCodeText(cryptoUtils.encryptId(String(teamId)));
    return ses.sendEmail(email, emailData);
};

auth.switchTeam = function (sessionId, userId, teamId, currentTeamId, pool) {
    var params = {};

    if (teamId === currentTeamId) {
        return Promise.resolve({});
    }

    params.team_id = Number(teamId);
    params.user_id = userId;

    return db.q(q['validate'], params, pool).then(function (rows) {
        if (!rows.length) {
            throw 'auth/team:400:Wrong team_id';
        }
    }).then(function () {
        return db.q(q['team'], {
            'team_id': teamId,
            'session_id': sessionId
        }, pool);
    }).then(function () {
        return {};
    });
};

auth.changePassword = function (userId, password, newPassword, pool) {
    if (!newPassword) {
        throw 'auth/password/change:400:Empty new password';
    }

    password = db.escape(password);
    newPassword = db.escape(newPassword);

    return db.q(q['password_get'], {
        'user_id': userId
    }, pool).then(function (rows) {
        if (!rows.length ||
            !bcrypt.compareSync(password, rows[0].password_hash)) {
            throw 'auth/password/change:400:Wrong password';
        }
        return db.q(q['password_set'], {
            'user_id': userId,
            'password_hash': bcrypt.hashSync(
                newPassword,
                bcrypt.genSaltSync(10)
            )
        }, pool);
    }).then(function () {
        return {};
    });
};

auth.listUserData = function (userId, pool) {
    return db.q(q['user_data_get'], {
        'user_id': userId
    }, pool).then(function (rows) {
        var ret = {};

        rows.forEach(function (row) {
            ret[row['key']] = row['value'];
        });

        return ret;
    });
};

auth.setUserData = function (userId, key, value, pool) {
    key = db.escape(key);
    value = db.escape(value);

    return db.q(q['user_data_set'], {
        'user_id': userId,
        'key': key,
        'value': value
    }, pool).then(function () {
        return {};
    });
};

auth.setTeamUserData = function (teamId, userId, key, value, pool) {
    var promises = [],
        getCats = function () {
            var cats = [];

            try {
                cats = JSON.parse(value);
            } catch (ignore) {
                //ignore
            }

            while (cats.length < 3) {
                cats.push(0);
            }

            return cats;
        };

    key = db.escape(key);
    value = db.escape(value);

    if (key === 'filter') {
        promises.push(rule.setDefault(
            teamId,
            getCats(),
            pool
        ));
    }

    promises.push(
        db.q(q['team_user_data_set'], {
            'team_id': teamId,
            'user_id': userId,
            'key': key,
            'value': value
        }, pool)
    );

    return Promise.all(promises).then(function () {
        return {};
    });
};

auth.getTeamUserData = function (teamId, userId, key, pool) {
    key = db.escape(key);

    return db.q(q['team_user_data_get'], {
        'team_id': teamId,
        'user_id': userId,
        'key': key
    }, pool).then(function (rows) {
        return rows[0] && rows[0].value || '';
    });
};

auth.getFilters = function (teamId, userId, pool) {
    return auth.getTeamUserData(
        teamId,
        userId,
        'filter',
        pool
    ).then(function (data) {
        if (data) {
            return JSON.parse(data);
        }

        return [];
    }).catch(function () {
        return [];
    });
};

auth.getTeams = function (sessionId, userId, isSuper, pool) {
    return db.q(q['get_teams'], {
        'session_id': sessionId,
        'user_id': userId,
        'is_super': isSuper
    }, pool).then(function (rows) {
        return rows;
    });
};

function insertInvitedUser (email, token, pool) {
    var userId;

    return db.q(q['insert_user'], {
        'email': email,
        'password_hash': 'invited'
    }, pool).then(function (result) {
        userId = result.insertId;
        return db.q(q['insert_lost_token'], {
            'user_id': userId,
            'token': token,
            'expire': Math.floor(Date.now() / 1000) +
                INVITE_TOKEN_TIMEOUT
        }, pool);
    }).then(function () {
        return userId;
    });
}

function getEmailText (alreadyRegistered, lostLink) {
    var subject,
        message = '';

    if (alreadyRegistered) {
        subject = 'You\'ve been invited to another team in Momentum';

        message += 'Hi there,\n\n';
        message += 'You\'ve been invited to use Momentum with another team.\n';
        message += 'Please log out, and when you log in again, ';
        message += 'you can choose which team you want to join.\n\n';
        message += 'If you have any questions or feel lost, ';
        message += 'drop us a mail at support@brandvee.com\n\n';
        message += 'Best,\n';
        message += 'Zoltan';
    } else {
        subject = 'You\'ve been invited to your team in Momentum';

        message += 'Hi there,\n\n';
        message += 'You\'ve been invited to use Momentum with your team. ';
        message += 'Here\'s what you need to do to join the fun:\n\n';
        message += 'Please copy & paste the following link in a browser ';
        message += 'to setup your password:\n';
        message += lostLink + '\n';
        message += 'You can only use this link once and ';
        message += 'the link expires in 7 days\n\n';
        message += 'Once you\'ve set up your password, ';
        message += 'download and install Momentum by following this link:\n';
        message += 'https://chrome.google.com/webstore/detail/';
        message += 'aeooeojbngloclgmeleimndcfaafnpcl\n\n';
        message += 'If you have any questions or feel lost, ';
        message += 'drop us a mail at support@momentum.ai\n\n';
        message += 'Best,\n';
        message += 'Zoltan';
    }
    return {
        'subject': subject,
        'message': message
    };
}

function getPasswordReminderText (lostLink) {
    var subject,
        message = '';

    subject = 'Reset password for Momentum';

    message += 'Hi there,\n\n';
    message += 'To set up a new password to your account ';
    message += 'just click the link below\n\n';
    message += lostLink + '\n';
    message += 'You can only use this link once and ';
    message += 'the link expires in 24 hours\n\n';
    message += 'If you have any questions or feel lost, ';
    message += 'drop us a mail at support@momentum.ai\n\n';
    message += 'Best,\n';
    message += 'Zoltan';

    return {
        'subject': subject,
        'message': message
    };
}

auth.inviteUser = function (userId, teamId, email, isAdmin, pool) {
    var token;

    if (!isAdmin) {
        throw 'model/auth:403:Unauthorized access';
    }

    token = crypto.randomBytes(10);
    token = token.toString('hex');

    return auth.invite(email, token, teamId, pool).then(function (resp) {
        var lostLink = [
                config.frontend.docBase,
                '#',
                'password-setup',
                email,
                token
            ].join('/'),
            emailData = getEmailText(resp.alreadyRegistered, lostLink);

        if (resp.newInTeam) {
            return ses.sendEmail(email, emailData);
        }
    }).then(function () {
        return auth.getUsers(userId, teamId, pool);
    });
};

auth.invite = function (email, token, teamId, pool) {
    var local = {
        'alreadyRegistered': 0,
        'newInTeam': 0
    };

    email = db.escape(email);

    return db.q(q['get_user'], {
        'email': email
    }, pool).then(function (rows) {
        if (!rows[0]) {
            return insertInvitedUser(
                email,
                token,
                pool
            ).then(function (userId) {
                local.userId = userId;
            });
        }

        local.alreadyRegistered = 1;
        local.userId = rows[0].id;
    }).then(function () {
        return db.q(q['get_team_user'], {
            'user_id': local.userId,
            'team_id': teamId
        }, pool);
    }).then(function (rows) {
        if (!rows[0]) {
            local.newInTeam = 1;
            return db.q(q['insert_team_user'], {
                'user_id': local.userId,
                'team_id': teamId
            }, pool).catch(function (err) {
                logger.error(err);
            });
        }
    }).then(function () {
        return {
            'newInTeam': local.newInTeam,
            'alreadyRegistered': local.alreadyRegistered
        };
    });
};

auth.forgotPassword = function (email, pool) {
    var token,
        userId;

    email = db.escape(email);
    token = crypto.randomBytes(10);
    token = token.toString('hex');
    return db.q(q['get_user'], {
        'email': email
    }, pool).then(function (rows) {
        if (!rows[0]) {
            throw 'model/auth:403:Unknown email';
        }
        userId = rows[0] && Number(rows[0].id) || 0;
    }).then(function () {
        if (userId) {
            return db.q(q['insert_lost_token'], {
                'user_id': userId,
                'token': token,
                'expire': Math.floor(Date.now() / 1000) +
                    REMINDER_TOKEN_TIMEOUT
            }, pool);
        }
    }).then(function () {
        var lostLink = [
            config.frontend.docBase,
            '#',
            'password-setup',
            email,
            token
        ].join('/');

        if (userId) {
            return ses.sendEmail(
                email,
                getPasswordReminderText(lostLink)
            );
        }
    }).then(function () {
        return 'Email sent';
    }).catch(function (err) {
        var msg;

        if (typeof err === 'string') {
            msg = err.split(':')[2];
            if (msg === 'Unknown email') {
                return 'Email sent';
            }
        }

        throw err;
    });
};

auth.setupPassword = function (email, token, password, pool) {
    var userId,
        salt = bcrypt.genSaltSync(10);

    email = db.escape(email);
    token = db.escape(token);
    password = db.escape(password);

    if (!password) {
        throw 'model/auth:403:Password required';
    }

    return db.q(q['get_user'], {
        'email': email
    }, pool).then(function (rows) {
        if (!rows[0]) {
            throw 'model/auth:403:Wrong or expired link';
        }
        userId = rows[0] && Number(rows[0].id) || 0;

        return db.q(q['get_user_lost_token'], {
            'user_id': userId,
            'token': token,
            'expire': Math.floor(Date.now() / 1000)
        }, pool);
    }).then(function (rows) {
        if (!rows[0]) {
            throw 'model/auth:403:Wrong or expired link';
        }

        return db.q(q['remove_user_lost_token'], {
            'remove_id': userId
        }, pool);
    }).then(function () {
        return db.q(q['remove_user_session'], {
            'remove_id': userId
        }, pool);
    }).then(function () {
        return db.q(q['password_set'], {
            'user_id': userId,
            'password_hash': bcrypt.hashSync(password, salt)
        }, pool);
    }).then(function () {
        return 'DONE';
    });
};

auth.switchAdminState = function (teamId, isAdmin, userId, state, pool) {
    var params = {
        'team_id': teamId,
        'user_id': userId,
        'state': state ? 0 : 1
    };

    if (!isAdmin) {
        throw 'model/auth:403:Unauthorized access';
    }

    return db.q(q['admin_state'], params, pool).then(function () {
        return {};
    });
};

module.exports = auth;
