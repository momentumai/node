var Promise = require('bluebird'),
    db = require('@lib/resources/db'),
    logger = require('@lib/logger')('model/session'),
    cryptoUtils = require('@lib/utils/crypto'),
    session = {};

session.get = function (sessionId, now, pool) {
    var sId,
        query = [
            'SELECT ',
            'session.id, ',
            'session.user_id, ',
            'session.team_id, ',
            'IFNULL(is_super, 0) as is_super, ',
            'IFNULL(is_admin OR is_super, 0) as is_admin, ',
            'timeout ',
            'FROM ',
            'session ',
            'LEFT JOIN ',
            'user ',
            'ON ',
            'user.id = session.user_id ',
            'LEFT JOIN ',
            'team_user ',
            'ON session.team_id = team_user.team_id ',
            'AND session.user_id = team_user.user_id ',
            'WHERE ',
            'session.id = {{session_id}} AND ',
            '((user.is_super IS NOT NULL AND user.is_super = 1) OR ',
            '(team_user.user_id IS NOT NULL));'
        ].join('');

    try {
        sId = cryptoUtils.decryptId(sessionId);
    } catch (e) {
        logger.debug(sessionId);
        return Promise.reject('model/session:401:Cannot parse session_id');
    }

    return db.q(query, {
        'session_id': sId
    }, pool).then(function (rows) {
        var session = rows[0];

        if (session && session.timeout >= now) {
            return Promise.resolve({
                'session_id': session.id,
                'user_id': session.user_id,
                'team_id': session.team_id,
                'is_admin': Number(session.is_admin),
                'is_super': Number(session.is_super)
            });
        }
        return Promise.reject('model/session:401:Session timeout');
    });
};

module.exports = session;
